// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: installer.proto

package v1

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/golang/protobuf/proto"
	_ "google.golang.org/genproto/googleapis/api/annotations"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

type File struct {
	Name                 string   `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	Content              []byte   `protobuf:"bytes,2,opt,name=content,proto3" json:"content,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *File) Reset()         { *m = File{} }
func (m *File) String() string { return proto.CompactTextString(m) }
func (*File) ProtoMessage()    {}
func (*File) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{0}
}
func (m *File) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *File) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_File.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *File) XXX_Merge(src proto.Message) {
	xxx_messageInfo_File.Merge(m, src)
}
func (m *File) XXX_Size() int {
	return m.Size()
}
func (m *File) XXX_DiscardUnknown() {
	xxx_messageInfo_File.DiscardUnknown(m)
}

var xxx_messageInfo_File proto.InternalMessageInfo

func (*File) XXX_MessageName() string {
	return "v1.File"
}

type TypeMeta struct {
	Kind                 string   `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	APIVersion           string   `protobuf:"bytes,2,opt,name=APIVersion,proto3" json:"APIVersion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypeMeta) Reset()         { *m = TypeMeta{} }
func (m *TypeMeta) String() string { return proto.CompactTextString(m) }
func (*TypeMeta) ProtoMessage()    {}
func (*TypeMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{1}
}
func (m *TypeMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TypeMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TypeMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TypeMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeMeta.Merge(m, src)
}
func (m *TypeMeta) XXX_Size() int {
	return m.Size()
}
func (m *TypeMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeMeta.DiscardUnknown(m)
}

var xxx_messageInfo_TypeMeta proto.InternalMessageInfo

func (*TypeMeta) XXX_MessageName() string {
	return "v1.TypeMeta"
}

// ObjectMeta is metadata that all persisted resources must have, which includes all objects
// users must create.
type ObjectMeta struct {
	Name                       string              `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	GenerateName               string              `protobuf:"bytes,2,opt,name=generateName,proto3" json:"generateName,omitempty"`
	Namespace                  string              `protobuf:"bytes,3,opt,name=namespace,proto3" json:"namespace,omitempty"`
	SelfLink                   string              `protobuf:"bytes,4,opt,name=selfLink,proto3" json:"selfLink,omitempty"`
	Uid                        string              `protobuf:"bytes,5,opt,name=uid,proto3" json:"uid,omitempty"`
	ResourceVersion            string              `protobuf:"bytes,6,opt,name=resourceVersion,proto3" json:"resourceVersion,omitempty"`
	Generation                 int64               `protobuf:"varint,7,opt,name=generation,proto3" json:"generation,omitempty"`
	CreationTimestamp          Time                `protobuf:"bytes,8,opt,name=creationTimestamp,proto3" json:"creationTimestamp"`
	DeletionTimestamp          *Time               `protobuf:"bytes,9,opt,name=deletionTimestamp,proto3" json:"deletionTimestamp,omitempty"`
	DeletionGracePeriodSeconds int64               `protobuf:"varint,10,opt,name=deletionGracePeriodSeconds,proto3" json:"deletionGracePeriodSeconds,omitempty"`
	Labels                     map[string]string   `protobuf:"bytes,11,rep,name=labels,proto3" json:"labels,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	Annotations                map[string]string   `protobuf:"bytes,12,rep,name=annotations,proto3" json:"annotations,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	OwnerReferences            []OwnerReference    `protobuf:"bytes,13,rep,name=ownerReferences,proto3" json:"ownerReferences"`
	Finalizers                 []string            `protobuf:"bytes,14,rep,name=finalizers,proto3" json:"finalizers,omitempty"`
	ClusterName                string              `protobuf:"bytes,15,opt,name=clusterName,proto3" json:"clusterName,omitempty"`
	ManagedFields              *ManagedFieldsEntry `protobuf:"bytes,17,opt,name=managedFields,proto3" json:"managedFields,omitempty"`
	XXX_NoUnkeyedLiteral       struct{}            `json:"-"`
	XXX_unrecognized           []byte              `json:"-"`
	XXX_sizecache              int32               `json:"-"`
}

func (m *ObjectMeta) Reset()         { *m = ObjectMeta{} }
func (m *ObjectMeta) String() string { return proto.CompactTextString(m) }
func (*ObjectMeta) ProtoMessage()    {}
func (*ObjectMeta) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{2}
}
func (m *ObjectMeta) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ObjectMeta) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ObjectMeta.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ObjectMeta) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ObjectMeta.Merge(m, src)
}
func (m *ObjectMeta) XXX_Size() int {
	return m.Size()
}
func (m *ObjectMeta) XXX_DiscardUnknown() {
	xxx_messageInfo_ObjectMeta.DiscardUnknown(m)
}

var xxx_messageInfo_ObjectMeta proto.InternalMessageInfo

func (*ObjectMeta) XXX_MessageName() string {
	return "v1.ObjectMeta"
}

// OwnerReference contains enough information to let you identify an owning
// object. An owning object must be in the same namespace as the dependent, or
// be cluster-scoped, so there is no namespace field.
type OwnerReference struct {
	// API version of the referent.
	ApiVersion string `protobuf:"bytes,5,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	// Kind of the referent.
	// More info: https://git.k8s.io/community/contributors/devel/api-conventions.md#types-kinds
	Kind string `protobuf:"bytes,1,opt,name=kind,proto3" json:"kind,omitempty"`
	// Name of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#names
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// UID of the referent.
	// More info: http://kubernetes.io/docs/user-guide/identifiers#uids
	Uid string `protobuf:"bytes,4,opt,name=uid,proto3" json:"uid,omitempty"`
	// If true, this reference points to the managing controller.
	// +
	Controller bool `protobuf:"varint,6,opt,name=controller,proto3" json:"controller,omitempty"`
	// If true, AND if the owner has the "foregroundDeletion" finalizer, then
	// the owner cannot be deleted from the key-value store until this
	// reference is removed.
	// Defaults to false.
	// To set this field, a user needs "delete" permission of the owner,
	// otherwise 422 (Unprocessable Entity) will be returned.
	// +
	BlockOwnerDeletion   bool     `protobuf:"varint,7,opt,name=blockOwnerDeletion,proto3" json:"blockOwnerDeletion,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OwnerReference) Reset()         { *m = OwnerReference{} }
func (m *OwnerReference) String() string { return proto.CompactTextString(m) }
func (*OwnerReference) ProtoMessage()    {}
func (*OwnerReference) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{3}
}
func (m *OwnerReference) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *OwnerReference) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_OwnerReference.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *OwnerReference) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OwnerReference.Merge(m, src)
}
func (m *OwnerReference) XXX_Size() int {
	return m.Size()
}
func (m *OwnerReference) XXX_DiscardUnknown() {
	xxx_messageInfo_OwnerReference.DiscardUnknown(m)
}

var xxx_messageInfo_OwnerReference proto.InternalMessageInfo

func (*OwnerReference) XXX_MessageName() string {
	return "v1.OwnerReference"
}

// ManagedFieldsEntry is a workflow-id, a FieldSet and the group version of the resource
// that the fieldset applies to.
type ManagedFieldsEntry struct {
	// Manager is an identifier of the workflow managing these fields.
	Manager string `protobuf:"bytes,1,opt,name=manager,proto3" json:"manager,omitempty"`
	// Operation is the type of operation which lead to this ManagedFieldsEntry being created.
	// The only valid values for this field are 'Apply' and 'Update'.
	Operation string `protobuf:"bytes,2,opt,name=operation,proto3" json:"operation,omitempty"`
	// APIVersion defines the version of this resource that this field set
	// applies to. The format is "group/version" just like the top-level
	// APIVersion field. It is necessary to track the version of a field
	// set because it cannot be automatically converted.
	ApiVersion string `protobuf:"bytes,3,opt,name=apiVersion,proto3" json:"apiVersion,omitempty"`
	// Time is timestamp of when these fields were set. It should always be empty if Operation is 'Apply'
	// +
	Time *Time `protobuf:"bytes,4,opt,name=time,proto3" json:"time,omitempty"`
	// Fields identifies a set of fields.
	// +
	Fields               *Fields  `protobuf:"bytes,5,opt,name=fields,proto3" json:"fields,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ManagedFieldsEntry) Reset()         { *m = ManagedFieldsEntry{} }
func (m *ManagedFieldsEntry) String() string { return proto.CompactTextString(m) }
func (*ManagedFieldsEntry) ProtoMessage()    {}
func (*ManagedFieldsEntry) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{4}
}
func (m *ManagedFieldsEntry) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ManagedFieldsEntry) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ManagedFieldsEntry.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ManagedFieldsEntry) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ManagedFieldsEntry.Merge(m, src)
}
func (m *ManagedFieldsEntry) XXX_Size() int {
	return m.Size()
}
func (m *ManagedFieldsEntry) XXX_DiscardUnknown() {
	xxx_messageInfo_ManagedFieldsEntry.DiscardUnknown(m)
}

var xxx_messageInfo_ManagedFieldsEntry proto.InternalMessageInfo

func (*ManagedFieldsEntry) XXX_MessageName() string {
	return "v1.ManagedFieldsEntry"
}

// Time is a wrapper around time.Time which supports correct
// marshaling to YAML and JSON.  Wrappers are provided for many
// of the factory methods that the time package offers.
//
// +protobuf.options.marshal=false
// +protobuf.as=Timestamp
// +protobuf.options.(gogoproto.goproto_stringer)=false
type Time struct {
	// Represents seconds of UTC time since Unix epoch
	// 1970-01-01T00:00:00Z. Must be from 0001-01-01T00:00:00Z to
	// 9999-12-31T23:59:59Z inclusive.
	Seconds int64 `protobuf:"varint,1,opt,name=seconds,proto3" json:"seconds,omitempty"`
	// Non-negative fractions of a second at nanosecond resolution. Negative
	// second values with fractions must still have non-negative nanos values
	// that count forward in time. Must be from 0 to 999,999,999
	// inclusive. This field may be limited in precision depending on context.
	Nanos                int32    `protobuf:"varint,2,opt,name=nanos,proto3" json:"nanos,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Time) Reset()         { *m = Time{} }
func (m *Time) String() string { return proto.CompactTextString(m) }
func (*Time) ProtoMessage()    {}
func (*Time) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{5}
}
func (m *Time) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Time) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Time.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Time) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Time.Merge(m, src)
}
func (m *Time) XXX_Size() int {
	return m.Size()
}
func (m *Time) XXX_DiscardUnknown() {
	xxx_messageInfo_Time.DiscardUnknown(m)
}

var xxx_messageInfo_Time proto.InternalMessageInfo

func (*Time) XXX_MessageName() string {
	return "v1.Time"
}

// Fields stores a set of fields in a data structure like a Trie.
// To understand how this is used, see: https://github.com/kubernetes-sigs/structured-merge-diff
type Fields struct {
	// Map stores a set of fields in a data structure like a Trie.
	//
	// Each key is either a '.' representing the field itself, and will always map to an empty set,
	// or a string representing a sub-field or item. The string will follow one of these four formats:
	// 'f:<name>', where <name> is the name of a field in a struct, or key in a map
	// 'v:<value>', where <value> is the exact json formatted value of a list item
	// 'i:<index>', where <index> is position of a item in a list
	// 'k:<keys>', where <keys> is a map of  a list item's key fields to their unique values
	// If a key maps to an empty Fields value, the field that key represents is part of the set.
	//
	// The exact format is defined in k8s.io/apiserver/pkg/endpoints/handlers/fieldmanager/internal
	Map                  map[string]*Fields `protobuf:"bytes,1,rep,name=map,proto3" json:"map,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}           `json:"-"`
	XXX_unrecognized     []byte             `json:"-"`
	XXX_sizecache        int32              `json:"-"`
}

func (m *Fields) Reset()         { *m = Fields{} }
func (m *Fields) String() string { return proto.CompactTextString(m) }
func (*Fields) ProtoMessage()    {}
func (*Fields) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{6}
}
func (m *Fields) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Fields) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Fields.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Fields) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Fields.Merge(m, src)
}
func (m *Fields) XXX_Size() int {
	return m.Size()
}
func (m *Fields) XXX_DiscardUnknown() {
	xxx_messageInfo_Fields.DiscardUnknown(m)
}

var xxx_messageInfo_Fields proto.InternalMessageInfo

func (*Fields) XXX_MessageName() string {
	return "v1.Fields"
}

type KubernetesClusterSpec struct {
	Cluster              Cluster  `protobuf:"bytes,1,opt,name=cluster,proto3" json:"cluster"`
	Addons               Addons   `protobuf:"bytes,2,opt,name=addons,proto3" json:"addons"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *KubernetesClusterSpec) Reset()         { *m = KubernetesClusterSpec{} }
func (m *KubernetesClusterSpec) String() string { return proto.CompactTextString(m) }
func (*KubernetesClusterSpec) ProtoMessage()    {}
func (*KubernetesClusterSpec) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{7}
}
func (m *KubernetesClusterSpec) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesClusterSpec) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesClusterSpec.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesClusterSpec) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesClusterSpec.Merge(m, src)
}
func (m *KubernetesClusterSpec) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesClusterSpec) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesClusterSpec.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesClusterSpec proto.InternalMessageInfo

func (*KubernetesClusterSpec) XXX_MessageName() string {
	return "v1.KubernetesClusterSpec"
}

type Cluster struct {
	TimeoutMins          string     `protobuf:"bytes,1,opt,name=timeoutMins,proto3" json:"timeoutMins,omitempty"`
	ClusterType          string     `protobuf:"bytes,2,opt,name=clusterType,proto3" json:"clusterType,omitempty"`
	PodCIDR              string     `protobuf:"bytes,3,opt,name=podCIDR,proto3" json:"podCIDR,omitempty"`
	ServiceCIDR          string     `protobuf:"bytes,4,opt,name=serviceCIDR,proto3" json:"serviceCIDR,omitempty"`
	MasterList           []Node     `protobuf:"bytes,5,rep,name=masterList,proto3" json:"masterList"`
	ExternalLoadBalancer string     `protobuf:"bytes,6,opt,name=externalLoadBalancer,proto3" json:"externalLoadBalancer,omitempty"`
	NodeList             []Node     `protobuf:"bytes,7,rep,name=nodeList,proto3" json:"nodeList"`
	EtcdList             []Node     `protobuf:"bytes,8,rep,name=etcdList,proto3" json:"etcdList"`
	Region               string     `protobuf:"bytes,9,opt,name=region,proto3" json:"region,omitempty"`
	AuthConfig           AuthConfig `protobuf:"bytes,10,opt,name=authConfig,proto3" json:"authConfig"`
	KubeVersion          string     `protobuf:"bytes,11,opt,name=kubeVersion,proto3" json:"kubeVersion,omitempty"`
	ImagesRegistry       string     `protobuf:"bytes,12,opt,name=imagesRegistry,proto3" json:"imagesRegistry,omitempty"`
	XXX_NoUnkeyedLiteral struct{}   `json:"-"`
	XXX_unrecognized     []byte     `json:"-"`
	XXX_sizecache        int32      `json:"-"`
}

func (m *Cluster) Reset()         { *m = Cluster{} }
func (m *Cluster) String() string { return proto.CompactTextString(m) }
func (*Cluster) ProtoMessage()    {}
func (*Cluster) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{8}
}
func (m *Cluster) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Cluster) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Cluster.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Cluster) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Cluster.Merge(m, src)
}
func (m *Cluster) XXX_Size() int {
	return m.Size()
}
func (m *Cluster) XXX_DiscardUnknown() {
	xxx_messageInfo_Cluster.DiscardUnknown(m)
}

var xxx_messageInfo_Cluster proto.InternalMessageInfo

func (*Cluster) XXX_MessageName() string {
	return "v1.Cluster"
}

type Addons struct {
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Addons) Reset()         { *m = Addons{} }
func (m *Addons) String() string { return proto.CompactTextString(m) }
func (*Addons) ProtoMessage()    {}
func (*Addons) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{9}
}
func (m *Addons) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Addons) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Addons.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Addons) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Addons.Merge(m, src)
}
func (m *Addons) XXX_Size() int {
	return m.Size()
}
func (m *Addons) XXX_DiscardUnknown() {
	xxx_messageInfo_Addons.DiscardUnknown(m)
}

var xxx_messageInfo_Addons proto.InternalMessageInfo

func (*Addons) XXX_MessageName() string {
	return "v1.Addons"
}

type Node struct {
	IP                   string   `protobuf:"bytes,1,opt,name=IP,proto3" json:"IP,omitempty"`
	Role                 string   `protobuf:"bytes,2,opt,name=role,proto3" json:"role,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Node) Reset()         { *m = Node{} }
func (m *Node) String() string { return proto.CompactTextString(m) }
func (*Node) ProtoMessage()    {}
func (*Node) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{10}
}
func (m *Node) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Node) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Node.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Node) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Node.Merge(m, src)
}
func (m *Node) XXX_Size() int {
	return m.Size()
}
func (m *Node) XXX_DiscardUnknown() {
	xxx_messageInfo_Node.DiscardUnknown(m)
}

var xxx_messageInfo_Node proto.InternalMessageInfo

func (*Node) XXX_MessageName() string {
	return "v1.Node"
}

type AuthConfig struct {
	Username             string   `protobuf:"bytes,1,opt,name=username,proto3" json:"username,omitempty"`
	Password             string   `protobuf:"bytes,2,opt,name=password,proto3" json:"password,omitempty"`
	PrivateSSHKey        string   `protobuf:"bytes,3,opt,name=privateSSHKey,proto3" json:"privateSSHKey,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *AuthConfig) Reset()         { *m = AuthConfig{} }
func (m *AuthConfig) String() string { return proto.CompactTextString(m) }
func (*AuthConfig) ProtoMessage()    {}
func (*AuthConfig) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{11}
}
func (m *AuthConfig) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthConfig) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthConfig.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthConfig) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthConfig.Merge(m, src)
}
func (m *AuthConfig) XXX_Size() int {
	return m.Size()
}
func (m *AuthConfig) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthConfig.DiscardUnknown(m)
}

var xxx_messageInfo_AuthConfig proto.InternalMessageInfo

func (*AuthConfig) XXX_MessageName() string {
	return "v1.AuthConfig"
}

type KubernetesClusterRequest struct {
	TypeMeta             `protobuf:"bytes,1,opt,name=typeMeta,proto3,embedded=typeMeta" json:"typeMeta"`
	ObjectMeta           `protobuf:"bytes,2,opt,name=objectMeta,proto3,embedded=objectMeta" json:"objectMeta"`
	Spec                 KubernetesClusterSpec `protobuf:"bytes,3,opt,name=spec,proto3" json:"spec"`
	XXX_NoUnkeyedLiteral struct{}              `json:"-"`
	XXX_unrecognized     []byte                `json:"-"`
	XXX_sizecache        int32                 `json:"-"`
}

func (m *KubernetesClusterRequest) Reset()         { *m = KubernetesClusterRequest{} }
func (m *KubernetesClusterRequest) String() string { return proto.CompactTextString(m) }
func (*KubernetesClusterRequest) ProtoMessage()    {}
func (*KubernetesClusterRequest) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{12}
}
func (m *KubernetesClusterRequest) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *KubernetesClusterRequest) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_KubernetesClusterRequest.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *KubernetesClusterRequest) XXX_Merge(src proto.Message) {
	xxx_messageInfo_KubernetesClusterRequest.Merge(m, src)
}
func (m *KubernetesClusterRequest) XXX_Size() int {
	return m.Size()
}
func (m *KubernetesClusterRequest) XXX_DiscardUnknown() {
	xxx_messageInfo_KubernetesClusterRequest.DiscardUnknown(m)
}

var xxx_messageInfo_KubernetesClusterRequest proto.InternalMessageInfo

func (*KubernetesClusterRequest) XXX_MessageName() string {
	return "v1.KubernetesClusterRequest"
}

type InstallClusterResponse struct {
	Success              bool     `protobuf:"varint,1,opt,name=success,proto3" json:"success,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InstallClusterResponse) Reset()         { *m = InstallClusterResponse{} }
func (m *InstallClusterResponse) String() string { return proto.CompactTextString(m) }
func (*InstallClusterResponse) ProtoMessage()    {}
func (*InstallClusterResponse) Descriptor() ([]byte, []int) {
	return fileDescriptor_675879a591bd3155, []int{13}
}
func (m *InstallClusterResponse) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *InstallClusterResponse) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_InstallClusterResponse.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalTo(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *InstallClusterResponse) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InstallClusterResponse.Merge(m, src)
}
func (m *InstallClusterResponse) XXX_Size() int {
	return m.Size()
}
func (m *InstallClusterResponse) XXX_DiscardUnknown() {
	xxx_messageInfo_InstallClusterResponse.DiscardUnknown(m)
}

var xxx_messageInfo_InstallClusterResponse proto.InternalMessageInfo

func (*InstallClusterResponse) XXX_MessageName() string {
	return "v1.InstallClusterResponse"
}
func init() {
	proto.RegisterType((*File)(nil), "v1.File")
	proto.RegisterType((*TypeMeta)(nil), "v1.TypeMeta")
	proto.RegisterType((*ObjectMeta)(nil), "v1.ObjectMeta")
	proto.RegisterMapType((map[string]string)(nil), "v1.ObjectMeta.AnnotationsEntry")
	proto.RegisterMapType((map[string]string)(nil), "v1.ObjectMeta.LabelsEntry")
	proto.RegisterType((*OwnerReference)(nil), "v1.OwnerReference")
	proto.RegisterType((*ManagedFieldsEntry)(nil), "v1.ManagedFieldsEntry")
	proto.RegisterType((*Time)(nil), "v1.Time")
	proto.RegisterType((*Fields)(nil), "v1.Fields")
	proto.RegisterMapType((map[string]*Fields)(nil), "v1.Fields.MapEntry")
	proto.RegisterType((*KubernetesClusterSpec)(nil), "v1.KubernetesClusterSpec")
	proto.RegisterType((*Cluster)(nil), "v1.Cluster")
	proto.RegisterType((*Addons)(nil), "v1.Addons")
	proto.RegisterType((*Node)(nil), "v1.Node")
	proto.RegisterType((*AuthConfig)(nil), "v1.AuthConfig")
	proto.RegisterType((*KubernetesClusterRequest)(nil), "v1.KubernetesClusterRequest")
	proto.RegisterType((*InstallClusterResponse)(nil), "v1.InstallClusterResponse")
}

func init() { proto.RegisterFile("installer.proto", fileDescriptor_675879a591bd3155) }

var fileDescriptor_675879a591bd3155 = []byte{
	// 1237 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x94, 0x56, 0xdf, 0x6e, 0x1b, 0x45,
	0x17, 0xcf, 0xc6, 0x8e, 0xb3, 0x3e, 0x4e, 0x9d, 0x76, 0xbe, 0x7e, 0xd1, 0x62, 0x22, 0xd7, 0xac,
	0x00, 0x59, 0x45, 0x38, 0xd4, 0xad, 0xaa, 0x52, 0x55, 0x95, 0x92, 0x94, 0x42, 0xd4, 0xa4, 0x44,
	0x9b, 0x8a, 0xfb, 0xf1, 0xee, 0x89, 0xbb, 0xcd, 0x7a, 0x66, 0x99, 0xd9, 0x4d, 0x09, 0x97, 0xbc,
	0x02, 0x37, 0x5c, 0xf1, 0x08, 0x3c, 0x00, 0x12, 0x12, 0x57, 0x28, 0x97, 0x95, 0xb8, 0xa6, 0x82,
	0x96, 0x07, 0x41, 0x73, 0x76, 0xd6, 0x5e, 0x27, 0x16, 0x12, 0x77, 0x73, 0x7e, 0xe7, 0xcf, 0x9c,
	0x39, 0xe7, 0x77, 0x66, 0x06, 0xd6, 0x63, 0xa1, 0x33, 0x9e, 0x24, 0xa8, 0x06, 0xa9, 0x92, 0x99,
	0x64, 0xcb, 0xa7, 0xb7, 0x3a, 0x1f, 0x8f, 0xe3, 0xec, 0x79, 0x3e, 0x1a, 0x84, 0x72, 0xb2, 0x35,
	0x96, 0x63, 0xb9, 0x45, 0xaa, 0x51, 0x7e, 0x4c, 0x12, 0x09, 0xb4, 0x2a, 0x5c, 0x3a, 0x9b, 0x63,
	0x29, 0xc7, 0x09, 0x6e, 0xf1, 0x34, 0xde, 0xe2, 0x42, 0xc8, 0x8c, 0x67, 0xb1, 0x14, 0xba, 0xd0,
	0xfa, 0x77, 0xa0, 0xfe, 0x38, 0x4e, 0x90, 0x31, 0xa8, 0x0b, 0x3e, 0x41, 0xcf, 0xe9, 0x39, 0xfd,
	0x66, 0x40, 0x6b, 0xe6, 0xc1, 0x6a, 0x28, 0x45, 0x86, 0x22, 0xf3, 0x96, 0x7b, 0x4e, 0x7f, 0x2d,
	0x28, 0x45, 0xff, 0x21, 0xb8, 0xcf, 0xce, 0x52, 0x3c, 0xc0, 0x8c, 0x1b, 0xcf, 0x93, 0x58, 0x44,
	0xa5, 0xa7, 0x59, 0xb3, 0x2e, 0xc0, 0xf6, 0xe1, 0xde, 0x57, 0xa8, 0x74, 0x2c, 0x05, 0x39, 0x37,
	0x83, 0x0a, 0xe2, 0xff, 0xd6, 0x00, 0xf8, 0x72, 0xf4, 0x02, 0xc3, 0xac, 0x0c, 0x71, 0x69, 0x73,
	0x1f, 0xd6, 0xc6, 0x28, 0x50, 0xf1, 0x0c, 0x9f, 0x1a, 0x5d, 0x11, 0x64, 0x0e, 0x63, 0x9b, 0xd0,
	0x34, 0xb6, 0x3a, 0xe5, 0x21, 0x7a, 0x35, 0x32, 0x98, 0x01, 0xac, 0x03, 0xae, 0xc6, 0xe4, 0x78,
	0x3f, 0x16, 0x27, 0x5e, 0x9d, 0x94, 0x53, 0x99, 0x5d, 0x85, 0x5a, 0x1e, 0x47, 0xde, 0x0a, 0xc1,
	0x66, 0xc9, 0xfa, 0xb0, 0xae, 0x50, 0xcb, 0x5c, 0x85, 0x58, 0xe6, 0xdd, 0x20, 0xed, 0x45, 0xd8,
	0x1c, 0xce, 0x66, 0x61, 0x8c, 0x56, 0x7b, 0x4e, 0xbf, 0x16, 0x54, 0x10, 0xf6, 0x00, 0xae, 0x85,
	0x0a, 0x69, 0xfd, 0x2c, 0x9e, 0xa0, 0xce, 0xf8, 0x24, 0xf5, 0xdc, 0x9e, 0xd3, 0x6f, 0x0d, 0xdd,
	0xc1, 0xe9, 0xad, 0x81, 0x01, 0x77, 0xea, 0xe7, 0xaf, 0x6f, 0x2c, 0x05, 0x97, 0x0d, 0xd9, 0x5d,
	0xb8, 0x16, 0x61, 0x82, 0xf3, 0xde, 0xcd, 0x79, 0xef, 0xe0, 0xb2, 0x09, 0x7b, 0x08, 0x9d, 0x12,
	0xfc, 0x5c, 0xf1, 0x10, 0x0f, 0x51, 0xc5, 0x32, 0x3a, 0xc2, 0x50, 0x8a, 0x48, 0x7b, 0x40, 0x59,
	0xfe, 0x8b, 0x05, 0x1b, 0x42, 0x23, 0xe1, 0x23, 0x4c, 0xb4, 0xd7, 0xea, 0xd5, 0xfa, 0xad, 0x61,
	0xc7, 0x6c, 0x36, 0xeb, 0xd1, 0x60, 0x9f, 0x94, 0x9f, 0x89, 0x4c, 0x9d, 0x05, 0xd6, 0x92, 0x6d,
	0x43, 0xab, 0xc2, 0x28, 0x6f, 0x8d, 0x1c, 0x6f, 0x5c, 0x70, 0xdc, 0x9e, 0x59, 0x14, 0xde, 0x55,
	0x1f, 0xb6, 0x03, 0xeb, 0xf2, 0xa5, 0x40, 0x15, 0xe0, 0x31, 0x2a, 0x14, 0x21, 0x6a, 0xef, 0x0a,
	0x85, 0x61, 0x14, 0x66, 0x4e, 0x65, 0x8b, 0x76, 0xd1, 0xc1, 0x34, 0xe4, 0x38, 0x16, 0x3c, 0x89,
	0xbf, 0x45, 0xa5, 0xbd, 0x76, 0xaf, 0x66, 0xd8, 0x36, 0x43, 0x58, 0x0f, 0x5a, 0x61, 0x92, 0xeb,
	0x0c, 0x15, 0x31, 0x69, 0x9d, 0xda, 0x5a, 0x85, 0xd8, 0x03, 0xb8, 0x32, 0xe1, 0x82, 0x8f, 0x31,
	0x7a, 0x1c, 0x63, 0x12, 0x69, 0xef, 0x1a, 0x15, 0x7c, 0xc3, 0xe4, 0x70, 0x50, 0x55, 0x14, 0x27,
	0x98, 0x37, 0xee, 0x7c, 0x0a, 0xad, 0x4a, 0x75, 0x0c, 0xb7, 0x4e, 0xf0, 0xcc, 0x92, 0xd9, 0x2c,
	0xd9, 0x75, 0x58, 0x39, 0xe5, 0x49, 0x5e, 0x92, 0xb8, 0x10, 0xee, 0x2f, 0xdf, 0x73, 0x3a, 0x0f,
	0xe1, 0xea, 0xc5, 0xfa, 0xfc, 0x17, 0x7f, 0xff, 0x67, 0x07, 0xda, 0xf3, 0x45, 0x32, 0xd5, 0xe0,
	0x69, 0x5c, 0x72, 0xb8, 0x60, 0x78, 0x05, 0x59, 0x38, 0xaf, 0xe5, 0x00, 0xd6, 0x2a, 0x03, 0x68,
	0x47, 0xa4, 0x3e, 0x1b, 0x91, 0x2e, 0x80, 0xb9, 0x00, 0x94, 0x34, 0x17, 0x12, 0x4d, 0x87, 0x1b,
	0x54, 0x10, 0x36, 0x00, 0x36, 0x4a, 0x64, 0x78, 0x42, 0x09, 0x3d, 0xb2, 0x54, 0xa3, 0x01, 0x71,
	0x83, 0x05, 0x1a, 0xff, 0x27, 0x07, 0xd8, 0xe5, 0xea, 0x9a, 0x6b, 0xa7, 0xa8, 0xaf, 0xb2, 0x39,
	0x96, 0xa2, 0x99, 0x77, 0x99, 0x96, 0x83, 0x57, 0xd4, 0x62, 0x06, 0x5c, 0x38, 0x78, 0xed, 0xd2,
	0xc1, 0x37, 0xa1, 0x9e, 0xc5, 0x13, 0xa4, 0x13, 0x55, 0x87, 0x89, 0x50, 0xe6, 0x43, 0xe3, 0xb8,
	0xe8, 0xfd, 0x0a, 0xe9, 0xc1, 0xe8, 0x8b, 0xb4, 0x02, 0xab, 0xf1, 0xef, 0x42, 0xdd, 0x78, 0x98,
	0x0c, 0xb5, 0x1d, 0x2c, 0x87, 0x06, 0xab, 0x14, 0x4d, 0xa7, 0x04, 0x17, 0x52, 0x53, 0x76, 0x2b,
	0x41, 0x21, 0xf8, 0x1a, 0x1a, 0x45, 0x24, 0xf6, 0x01, 0xd4, 0x26, 0x3c, 0xf5, 0x1c, 0xa2, 0xf8,
	0xff, 0x66, 0x5b, 0x0c, 0x0e, 0x78, 0x5a, 0x70, 0xcb, 0xe8, 0x3b, 0x3b, 0xe0, 0x96, 0xc0, 0x02,
	0x3a, 0xf4, 0xaa, 0x74, 0x98, 0xcf, 0xb4, 0x42, 0x0d, 0x01, 0xff, 0x7f, 0x92, 0x8f, 0x50, 0x09,
	0xcc, 0x50, 0xef, 0x16, 0x64, 0x3f, 0x4a, 0x31, 0x64, 0x1f, 0xc1, 0xaa, 0xe5, 0x3e, 0x05, 0x6d,
	0x0d, 0x5b, 0x26, 0x80, 0xb5, 0xb0, 0x33, 0x56, 0x5a, 0xb0, 0x3e, 0x34, 0x78, 0x14, 0x99, 0xe9,
	0xae, 0x6c, 0xb6, 0x4d, 0x88, 0x35, 0xb5, 0x7a, 0xff, 0x8f, 0x1a, 0xac, 0xda, 0x20, 0x66, 0xe2,
	0x4c, 0x51, 0x65, 0x9e, 0x1d, 0xc4, 0x42, 0xdb, 0xdc, 0xab, 0x50, 0x65, 0x26, 0xcd, 0x43, 0x62,
	0x9b, 0x59, 0x85, 0x4c, 0x91, 0x53, 0x19, 0xed, 0xee, 0x3d, 0x0a, 0x6c, 0x2f, 0x4b, 0xd1, 0xf8,
	0x6a, 0x54, 0xa7, 0x71, 0x88, 0xa4, 0x2d, 0x18, 0x5a, 0x85, 0xd8, 0x00, 0x60, 0xc2, 0x4d, 0xa4,
	0xfd, 0x58, 0x67, 0xde, 0x0a, 0x55, 0x9b, 0x1a, 0xfe, 0x54, 0x46, 0xe5, 0x35, 0x52, 0xb1, 0x60,
	0x43, 0xb8, 0x8e, 0xdf, 0x64, 0xa8, 0x04, 0x4f, 0xf6, 0x25, 0x8f, 0x76, 0x78, 0xc2, 0x45, 0x68,
	0x39, 0xde, 0x0c, 0x16, 0xea, 0xd8, 0x4d, 0x70, 0x85, 0x8c, 0x90, 0x76, 0x58, 0x5d, 0xb8, 0xc3,
	0x54, 0x6f, 0x6c, 0x31, 0x0b, 0x23, 0xb2, 0x75, 0x17, 0xdb, 0x96, 0x7a, 0xb6, 0x01, 0x0d, 0x85,
	0x63, 0x43, 0xe1, 0x26, 0xed, 0x6e, 0x25, 0x76, 0x07, 0x80, 0xe7, 0xd9, 0xf3, 0x5d, 0x29, 0x8e,
	0xe3, 0x31, 0x5d, 0xe8, 0xad, 0x61, 0x9b, 0xba, 0x31, 0x45, 0xcb, 0x93, 0xcd, 0xec, 0x4c, 0xad,
	0x4e, 0xf2, 0xd1, 0xf4, 0x49, 0x6b, 0x15, 0xb5, 0xaa, 0x40, 0xec, 0x43, 0x68, 0xc7, 0x13, 0x3e,
	0x46, 0x1d, 0xe0, 0x38, 0xd6, 0x99, 0x3a, 0xf3, 0xd6, 0xc8, 0xe8, 0x02, 0xea, 0xbb, 0xd0, 0x28,
	0xfa, 0xee, 0xdf, 0x84, 0xba, 0xc9, 0x9c, 0xb5, 0x61, 0x79, 0xef, 0xd0, 0x36, 0x77, 0x79, 0xef,
	0xd0, 0xdc, 0x22, 0x4a, 0x26, 0x65, 0x33, 0x69, 0xed, 0xbf, 0x00, 0x98, 0xe5, 0x67, 0x9e, 0xe4,
	0x5c, 0x9b, 0x52, 0x4e, 0x1f, 0xfb, 0xa9, 0x6c, 0x74, 0x29, 0xd7, 0xfa, 0xa5, 0x54, 0x91, 0x8d,
	0x30, 0x95, 0xd9, 0xfb, 0x70, 0x25, 0x55, 0xf1, 0x29, 0xcf, 0xf0, 0xe8, 0xe8, 0x8b, 0x27, 0x78,
	0x66, 0x19, 0x31, 0x0f, 0xfa, 0xbf, 0x38, 0xe0, 0x5d, 0xa2, 0x7c, 0x80, 0x5f, 0xe7, 0x48, 0x2d,
	0x76, 0x33, 0xfb, 0x65, 0xb1, 0xb4, 0x5f, 0xa3, 0x1b, 0xc0, 0x62, 0x3b, 0xae, 0x29, 0xdd, 0xab,
	0xd7, 0x37, 0x9c, 0x60, 0x6a, 0xc7, 0xee, 0x01, 0xc8, 0xe9, 0x43, 0x66, 0x07, 0xa0, 0x3d, 0xff,
	0xbc, 0x55, 0xfc, 0x2a, 0xb6, 0xec, 0x36, 0xd4, 0x75, 0x8a, 0x21, 0xe5, 0xd9, 0x1a, 0xbe, 0x63,
	0x7c, 0x16, 0x0e, 0xa3, 0xed, 0x18, 0x19, 0xfb, 0x43, 0xd8, 0xd8, 0x2b, 0xfe, 0x7b, 0xd3, 0xdc,
	0x75, 0x2a, 0x85, 0x2e, 0x2e, 0x9c, 0x3c, 0x0c, 0x51, 0x17, 0xb3, 0xe4, 0x06, 0xa5, 0x38, 0xfc,
	0xd1, 0x81, 0xe6, 0x5e, 0xf9, 0x49, 0x64, 0x3e, 0xb8, 0xbb, 0x32, 0x3d, 0xa3, 0x1f, 0x9d, 0x5b,
	0x5c, 0x0b, 0x09, 0x76, 0xa6, 0x2b, 0x7f, 0xe9, 0x13, 0x87, 0x4d, 0xa0, 0x3d, 0xbf, 0x0b, 0xdb,
	0x5c, 0x98, 0x9e, 0x2d, 0x5c, 0x87, 0x3e, 0x02, 0x8b, 0xf3, 0xf2, 0xdf, 0xfb, 0xee, 0xf7, 0xbf,
	0xbf, 0x5f, 0x7e, 0xd7, 0xdf, 0xa0, 0xdf, 0xe5, 0xe9, 0xad, 0x2d, 0x3b, 0xc0, 0x5b, 0xf4, 0xaf,
	0xc1, 0xfb, 0xce, 0xcd, 0x9d, 0xcd, 0xf3, 0xbf, 0xba, 0x4b, 0xe7, 0x6f, 0xba, 0xce, 0xab, 0x37,
	0x5d, 0xe7, 0xcf, 0x37, 0x5d, 0xe7, 0x87, 0xb7, 0xdd, 0xa5, 0x5f, 0xdf, 0x76, 0x9d, 0xf3, 0xb7,
	0x5d, 0x67, 0xd4, 0xa0, 0x5f, 0xe8, 0xed, 0x7f, 0x02, 0x00, 0x00, 0xff, 0xff, 0x22, 0x17, 0x02,
	0x5c, 0xe9, 0x0a, 0x00, 0x00,
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// InstallerClient is the client API for Installer service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type InstallerClient interface {
	// copy file
	CopyFile(ctx context.Context, in *File, opts ...grpc.CallOption) (Installer_CopyFileClient, error)
	// dispatch cluster config to all agent
	InstallCluster(ctx context.Context, in *KubernetesClusterRequest, opts ...grpc.CallOption) (*InstallClusterResponse, error)
}

type installerClient struct {
	cc *grpc.ClientConn
}

func NewInstallerClient(cc *grpc.ClientConn) InstallerClient {
	return &installerClient{cc}
}

func (c *installerClient) CopyFile(ctx context.Context, in *File, opts ...grpc.CallOption) (Installer_CopyFileClient, error) {
	stream, err := c.cc.NewStream(ctx, &_Installer_serviceDesc.Streams[0], "/v1.Installer/CopyFile", opts...)
	if err != nil {
		return nil, err
	}
	x := &installerCopyFileClient{stream}
	if err := x.ClientStream.SendMsg(in); err != nil {
		return nil, err
	}
	if err := x.ClientStream.CloseSend(); err != nil {
		return nil, err
	}
	return x, nil
}

type Installer_CopyFileClient interface {
	Recv() (*File, error)
	grpc.ClientStream
}

type installerCopyFileClient struct {
	grpc.ClientStream
}

func (x *installerCopyFileClient) Recv() (*File, error) {
	m := new(File)
	if err := x.ClientStream.RecvMsg(m); err != nil {
		return nil, err
	}
	return m, nil
}

func (c *installerClient) InstallCluster(ctx context.Context, in *KubernetesClusterRequest, opts ...grpc.CallOption) (*InstallClusterResponse, error) {
	out := new(InstallClusterResponse)
	err := c.cc.Invoke(ctx, "/v1.Installer/InstallCluster", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// InstallerServer is the server API for Installer service.
type InstallerServer interface {
	// copy file
	CopyFile(*File, Installer_CopyFileServer) error
	// dispatch cluster config to all agent
	InstallCluster(context.Context, *KubernetesClusterRequest) (*InstallClusterResponse, error)
}

// UnimplementedInstallerServer can be embedded to have forward compatible implementations.
type UnimplementedInstallerServer struct {
}

func (*UnimplementedInstallerServer) CopyFile(req *File, srv Installer_CopyFileServer) error {
	return status.Errorf(codes.Unimplemented, "method CopyFile not implemented")
}
func (*UnimplementedInstallerServer) InstallCluster(ctx context.Context, req *KubernetesClusterRequest) (*InstallClusterResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InstallCluster not implemented")
}

func RegisterInstallerServer(s *grpc.Server, srv InstallerServer) {
	s.RegisterService(&_Installer_serviceDesc, srv)
}

func _Installer_CopyFile_Handler(srv interface{}, stream grpc.ServerStream) error {
	m := new(File)
	if err := stream.RecvMsg(m); err != nil {
		return err
	}
	return srv.(InstallerServer).CopyFile(m, &installerCopyFileServer{stream})
}

type Installer_CopyFileServer interface {
	Send(*File) error
	grpc.ServerStream
}

type installerCopyFileServer struct {
	grpc.ServerStream
}

func (x *installerCopyFileServer) Send(m *File) error {
	return x.ServerStream.SendMsg(m)
}

func _Installer_InstallCluster_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(KubernetesClusterRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(InstallerServer).InstallCluster(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/v1.Installer/InstallCluster",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(InstallerServer).InstallCluster(ctx, req.(*KubernetesClusterRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _Installer_serviceDesc = grpc.ServiceDesc{
	ServiceName: "v1.Installer",
	HandlerType: (*InstallerServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "InstallCluster",
			Handler:    _Installer_InstallCluster_Handler,
		},
	},
	Streams: []grpc.StreamDesc{
		{
			StreamName:    "CopyFile",
			Handler:       _Installer_CopyFile_Handler,
			ServerStreams: true,
		},
	},
	Metadata: "installer.proto",
}

func (m *File) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *File) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Content) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Content)))
		i += copy(dAtA[i:], m.Content)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *TypeMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TypeMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.APIVersion) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.APIVersion)))
		i += copy(dAtA[i:], m.APIVersion)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ObjectMeta) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ObjectMeta) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Name) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.GenerateName) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.GenerateName)))
		i += copy(dAtA[i:], m.GenerateName)
	}
	if len(m.Namespace) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Namespace)))
		i += copy(dAtA[i:], m.Namespace)
	}
	if len(m.SelfLink) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.SelfLink)))
		i += copy(dAtA[i:], m.SelfLink)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.ResourceVersion) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ResourceVersion)))
		i += copy(dAtA[i:], m.ResourceVersion)
	}
	if m.Generation != 0 {
		dAtA[i] = 0x38
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.Generation))
	}
	dAtA[i] = 0x42
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.CreationTimestamp.Size()))
	n1, err1 := m.CreationTimestamp.MarshalTo(dAtA[i:])
	if err1 != nil {
		return 0, err1
	}
	i += n1
	if m.DeletionTimestamp != nil {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.DeletionTimestamp.Size()))
		n2, err2 := m.DeletionTimestamp.MarshalTo(dAtA[i:])
		if err2 != nil {
			return 0, err2
		}
		i += n2
	}
	if m.DeletionGracePeriodSeconds != 0 {
		dAtA[i] = 0x50
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.DeletionGracePeriodSeconds))
	}
	if len(m.Labels) > 0 {
		for k, _ := range m.Labels {
			dAtA[i] = 0x5a
			i++
			v := m.Labels[k]
			mapSize := 1 + len(k) + sovInstaller(uint64(len(k))) + 1 + len(v) + sovInstaller(uint64(len(v)))
			i = encodeVarintInstaller(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.Annotations) > 0 {
		for k, _ := range m.Annotations {
			dAtA[i] = 0x62
			i++
			v := m.Annotations[k]
			mapSize := 1 + len(k) + sovInstaller(uint64(len(k))) + 1 + len(v) + sovInstaller(uint64(len(v)))
			i = encodeVarintInstaller(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			dAtA[i] = 0x12
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(len(v)))
			i += copy(dAtA[i:], v)
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, msg := range m.OwnerReferences {
			dAtA[i] = 0x6a
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			dAtA[i] = 0x72
			i++
			l = len(s)
			for l >= 1<<7 {
				dAtA[i] = uint8(uint64(l)&0x7f | 0x80)
				l >>= 7
				i++
			}
			dAtA[i] = uint8(l)
			i++
			i += copy(dAtA[i:], s)
		}
	}
	if len(m.ClusterName) > 0 {
		dAtA[i] = 0x7a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ClusterName)))
		i += copy(dAtA[i:], m.ClusterName)
	}
	if m.ManagedFields != nil {
		dAtA[i] = 0x8a
		i++
		dAtA[i] = 0x1
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.ManagedFields.Size()))
		n3, err3 := m.ManagedFields.MarshalTo(dAtA[i:])
		if err3 != nil {
			return 0, err3
		}
		i += n3
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *OwnerReference) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *OwnerReference) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Kind) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Kind)))
		i += copy(dAtA[i:], m.Kind)
	}
	if len(m.Name) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Name)))
		i += copy(dAtA[i:], m.Name)
	}
	if len(m.Uid) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Uid)))
		i += copy(dAtA[i:], m.Uid)
	}
	if len(m.ApiVersion) > 0 {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ApiVersion)))
		i += copy(dAtA[i:], m.ApiVersion)
	}
	if m.Controller {
		dAtA[i] = 0x30
		i++
		if m.Controller {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.BlockOwnerDeletion {
		dAtA[i] = 0x38
		i++
		if m.BlockOwnerDeletion {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *ManagedFieldsEntry) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ManagedFieldsEntry) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Manager) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Manager)))
		i += copy(dAtA[i:], m.Manager)
	}
	if len(m.Operation) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Operation)))
		i += copy(dAtA[i:], m.Operation)
	}
	if len(m.ApiVersion) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ApiVersion)))
		i += copy(dAtA[i:], m.ApiVersion)
	}
	if m.Time != nil {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.Time.Size()))
		n4, err4 := m.Time.MarshalTo(dAtA[i:])
		if err4 != nil {
			return 0, err4
		}
		i += n4
	}
	if m.Fields != nil {
		dAtA[i] = 0x2a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.Fields.Size()))
		n5, err5 := m.Fields.MarshalTo(dAtA[i:])
		if err5 != nil {
			return 0, err5
		}
		i += n5
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Time) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Time) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Seconds != 0 {
		dAtA[i] = 0x8
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		dAtA[i] = 0x10
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(m.Nanos))
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Fields) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Fields) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, _ := range m.Map {
			dAtA[i] = 0xa
			i++
			v := m.Map[k]
			msgSize := 0
			if v != nil {
				msgSize = v.Size()
				msgSize += 1 + sovInstaller(uint64(msgSize))
			}
			mapSize := 1 + len(k) + sovInstaller(uint64(len(k))) + msgSize
			i = encodeVarintInstaller(dAtA, i, uint64(mapSize))
			dAtA[i] = 0xa
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(len(k)))
			i += copy(dAtA[i:], k)
			if v != nil {
				dAtA[i] = 0x12
				i++
				i = encodeVarintInstaller(dAtA, i, uint64(v.Size()))
				n6, err6 := v.MarshalTo(dAtA[i:])
				if err6 != nil {
					return 0, err6
				}
				i += n6
			}
		}
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesClusterSpec) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesClusterSpec) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.Cluster.Size()))
	n7, err7 := m.Cluster.MarshalTo(dAtA[i:])
	if err7 != nil {
		return 0, err7
	}
	i += n7
	dAtA[i] = 0x12
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.Addons.Size()))
	n8, err8 := m.Addons.MarshalTo(dAtA[i:])
	if err8 != nil {
		return 0, err8
	}
	i += n8
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Cluster) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Cluster) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.TimeoutMins) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.TimeoutMins)))
		i += copy(dAtA[i:], m.TimeoutMins)
	}
	if len(m.ClusterType) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ClusterType)))
		i += copy(dAtA[i:], m.ClusterType)
	}
	if len(m.PodCIDR) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.PodCIDR)))
		i += copy(dAtA[i:], m.PodCIDR)
	}
	if len(m.ServiceCIDR) > 0 {
		dAtA[i] = 0x22
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ServiceCIDR)))
		i += copy(dAtA[i:], m.ServiceCIDR)
	}
	if len(m.MasterList) > 0 {
		for _, msg := range m.MasterList {
			dAtA[i] = 0x2a
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.ExternalLoadBalancer) > 0 {
		dAtA[i] = 0x32
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ExternalLoadBalancer)))
		i += copy(dAtA[i:], m.ExternalLoadBalancer)
	}
	if len(m.NodeList) > 0 {
		for _, msg := range m.NodeList {
			dAtA[i] = 0x3a
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.EtcdList) > 0 {
		for _, msg := range m.EtcdList {
			dAtA[i] = 0x42
			i++
			i = encodeVarintInstaller(dAtA, i, uint64(msg.Size()))
			n, err := msg.MarshalTo(dAtA[i:])
			if err != nil {
				return 0, err
			}
			i += n
		}
	}
	if len(m.Region) > 0 {
		dAtA[i] = 0x4a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Region)))
		i += copy(dAtA[i:], m.Region)
	}
	dAtA[i] = 0x52
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.AuthConfig.Size()))
	n9, err9 := m.AuthConfig.MarshalTo(dAtA[i:])
	if err9 != nil {
		return 0, err9
	}
	i += n9
	if len(m.KubeVersion) > 0 {
		dAtA[i] = 0x5a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.KubeVersion)))
		i += copy(dAtA[i:], m.KubeVersion)
	}
	if len(m.ImagesRegistry) > 0 {
		dAtA[i] = 0x62
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.ImagesRegistry)))
		i += copy(dAtA[i:], m.ImagesRegistry)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Addons) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Addons) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *Node) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Node) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.IP) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.IP)))
		i += copy(dAtA[i:], m.IP)
	}
	if len(m.Role) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Role)))
		i += copy(dAtA[i:], m.Role)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *AuthConfig) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthConfig) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if len(m.Username) > 0 {
		dAtA[i] = 0xa
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Username)))
		i += copy(dAtA[i:], m.Username)
	}
	if len(m.Password) > 0 {
		dAtA[i] = 0x12
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.Password)))
		i += copy(dAtA[i:], m.Password)
	}
	if len(m.PrivateSSHKey) > 0 {
		dAtA[i] = 0x1a
		i++
		i = encodeVarintInstaller(dAtA, i, uint64(len(m.PrivateSSHKey)))
		i += copy(dAtA[i:], m.PrivateSSHKey)
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *KubernetesClusterRequest) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *KubernetesClusterRequest) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	dAtA[i] = 0xa
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.TypeMeta.Size()))
	n10, err10 := m.TypeMeta.MarshalTo(dAtA[i:])
	if err10 != nil {
		return 0, err10
	}
	i += n10
	dAtA[i] = 0x12
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.ObjectMeta.Size()))
	n11, err11 := m.ObjectMeta.MarshalTo(dAtA[i:])
	if err11 != nil {
		return 0, err11
	}
	i += n11
	dAtA[i] = 0x1a
	i++
	i = encodeVarintInstaller(dAtA, i, uint64(m.Spec.Size()))
	n12, err12 := m.Spec.MarshalTo(dAtA[i:])
	if err12 != nil {
		return 0, err12
	}
	i += n12
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func (m *InstallClusterResponse) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalTo(dAtA)
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *InstallClusterResponse) MarshalTo(dAtA []byte) (int, error) {
	var i int
	_ = i
	var l int
	_ = l
	if m.Success {
		dAtA[i] = 0x8
		i++
		if m.Success {
			dAtA[i] = 1
		} else {
			dAtA[i] = 0
		}
		i++
	}
	if m.XXX_unrecognized != nil {
		i += copy(dAtA[i:], m.XXX_unrecognized)
	}
	return i, nil
}

func encodeVarintInstaller(dAtA []byte, offset int, v uint64) int {
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return offset + 1
}
func (m *File) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Content)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TypeMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.APIVersion)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ObjectMeta) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.GenerateName)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Namespace)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.SelfLink)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ResourceVersion)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.Generation != 0 {
		n += 1 + sovInstaller(uint64(m.Generation))
	}
	l = m.CreationTimestamp.Size()
	n += 1 + l + sovInstaller(uint64(l))
	if m.DeletionTimestamp != nil {
		l = m.DeletionTimestamp.Size()
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.DeletionGracePeriodSeconds != 0 {
		n += 1 + sovInstaller(uint64(m.DeletionGracePeriodSeconds))
	}
	if len(m.Labels) > 0 {
		for k, v := range m.Labels {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovInstaller(uint64(len(k))) + 1 + len(v) + sovInstaller(uint64(len(v)))
			n += mapEntrySize + 1 + sovInstaller(uint64(mapEntrySize))
		}
	}
	if len(m.Annotations) > 0 {
		for k, v := range m.Annotations {
			_ = k
			_ = v
			mapEntrySize := 1 + len(k) + sovInstaller(uint64(len(k))) + 1 + len(v) + sovInstaller(uint64(len(v)))
			n += mapEntrySize + 1 + sovInstaller(uint64(mapEntrySize))
		}
	}
	if len(m.OwnerReferences) > 0 {
		for _, e := range m.OwnerReferences {
			l = e.Size()
			n += 1 + l + sovInstaller(uint64(l))
		}
	}
	if len(m.Finalizers) > 0 {
		for _, s := range m.Finalizers {
			l = len(s)
			n += 1 + l + sovInstaller(uint64(l))
		}
	}
	l = len(m.ClusterName)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.ManagedFields != nil {
		l = m.ManagedFields.Size()
		n += 2 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *OwnerReference) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Kind)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Name)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Uid)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.Controller {
		n += 2
	}
	if m.BlockOwnerDeletion {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *ManagedFieldsEntry) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Manager)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Operation)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ApiVersion)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.Time != nil {
		l = m.Time.Size()
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.Fields != nil {
		l = m.Fields.Size()
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Time) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Seconds != 0 {
		n += 1 + sovInstaller(uint64(m.Seconds))
	}
	if m.Nanos != 0 {
		n += 1 + sovInstaller(uint64(m.Nanos))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Fields) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Map) > 0 {
		for k, v := range m.Map {
			_ = k
			_ = v
			l = 0
			if v != nil {
				l = v.Size()
				l += 1 + sovInstaller(uint64(l))
			}
			mapEntrySize := 1 + len(k) + sovInstaller(uint64(len(k))) + l
			n += mapEntrySize + 1 + sovInstaller(uint64(mapEntrySize))
		}
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesClusterSpec) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.Cluster.Size()
	n += 1 + l + sovInstaller(uint64(l))
	l = m.Addons.Size()
	n += 1 + l + sovInstaller(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Cluster) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.TimeoutMins)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ClusterType)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.PodCIDR)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ServiceCIDR)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if len(m.MasterList) > 0 {
		for _, e := range m.MasterList {
			l = e.Size()
			n += 1 + l + sovInstaller(uint64(l))
		}
	}
	l = len(m.ExternalLoadBalancer)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if len(m.NodeList) > 0 {
		for _, e := range m.NodeList {
			l = e.Size()
			n += 1 + l + sovInstaller(uint64(l))
		}
	}
	if len(m.EtcdList) > 0 {
		for _, e := range m.EtcdList {
			l = e.Size()
			n += 1 + l + sovInstaller(uint64(l))
		}
	}
	l = len(m.Region)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = m.AuthConfig.Size()
	n += 1 + l + sovInstaller(uint64(l))
	l = len(m.KubeVersion)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.ImagesRegistry)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Addons) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Node) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.IP)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Role)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthConfig) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.Username)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.Password)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	l = len(m.PrivateSSHKey)
	if l > 0 {
		n += 1 + l + sovInstaller(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *KubernetesClusterRequest) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = m.TypeMeta.Size()
	n += 1 + l + sovInstaller(uint64(l))
	l = m.ObjectMeta.Size()
	n += 1 + l + sovInstaller(uint64(l))
	l = m.Spec.Size()
	n += 1 + l + sovInstaller(uint64(l))
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *InstallClusterResponse) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Success {
		n += 2
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovInstaller(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozInstaller(x uint64) (n int) {
	return sovInstaller(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *File) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: File: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: File: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Content", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Content = append(m.Content[:0], dAtA[iNdEx:postIndex]...)
			if m.Content == nil {
				m.Content = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TypeMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TypeMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TypeMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field APIVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.APIVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ObjectMeta) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ObjectMeta: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ObjectMeta: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field GenerateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.GenerateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Namespace", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Namespace = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SelfLink", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SelfLink = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ResourceVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ResourceVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Generation", wireType)
			}
			m.Generation = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Generation |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field CreationTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.CreationTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionTimestamp", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.DeletionTimestamp == nil {
				m.DeletionTimestamp = &Time{}
			}
			if err := m.DeletionTimestamp.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 10:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeletionGracePeriodSeconds", wireType)
			}
			m.DeletionGracePeriodSeconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.DeletionGracePeriodSeconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Labels", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Labels == nil {
				m.Labels = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInstaller
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthInstaller
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthInstaller
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInstaller(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthInstaller
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Labels[mapkey] = mapvalue
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Annotations", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Annotations == nil {
				m.Annotations = make(map[string]string)
			}
			var mapkey string
			var mapvalue string
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInstaller
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var stringLenmapvalue uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapvalue |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapvalue := int(stringLenmapvalue)
					if intStringLenmapvalue < 0 {
						return ErrInvalidLengthInstaller
					}
					postStringIndexmapvalue := iNdEx + intStringLenmapvalue
					if postStringIndexmapvalue < 0 {
						return ErrInvalidLengthInstaller
					}
					if postStringIndexmapvalue > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = string(dAtA[iNdEx:postStringIndexmapvalue])
					iNdEx = postStringIndexmapvalue
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInstaller(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthInstaller
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Annotations[mapkey] = mapvalue
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field OwnerReferences", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.OwnerReferences = append(m.OwnerReferences, OwnerReference{})
			if err := m.OwnerReferences[len(m.OwnerReferences)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Finalizers", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Finalizers = append(m.Finalizers, string(dAtA[iNdEx:postIndex]))
			iNdEx = postIndex
		case 15:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 17:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ManagedFields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.ManagedFields == nil {
				m.ManagedFields = &ManagedFieldsEntry{}
			}
			if err := m.ManagedFields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *OwnerReference) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: OwnerReference: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: OwnerReference: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Kind", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Kind = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Name", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Name = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Uid", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Uid = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Controller", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Controller = bool(v != 0)
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field BlockOwnerDeletion", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.BlockOwnerDeletion = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *ManagedFieldsEntry) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ManagedFieldsEntry: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ManagedFieldsEntry: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Manager", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Manager = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Operation", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Operation = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ApiVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Time", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Time == nil {
				m.Time = &Time{}
			}
			if err := m.Time.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Fields", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Fields == nil {
				m.Fields = &Fields{}
			}
			if err := m.Fields.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Time) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Time: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Time: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Seconds", wireType)
			}
			m.Seconds = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Seconds |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nanos", wireType)
			}
			m.Nanos = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nanos |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Fields) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Fields: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Fields: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Map", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Map == nil {
				m.Map = make(map[string]*Fields)
			}
			var mapkey string
			var mapvalue *Fields
			for iNdEx < postIndex {
				entryPreIndex := iNdEx
				var wire uint64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowInstaller
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					wire |= uint64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				fieldNum := int32(wire >> 3)
				if fieldNum == 1 {
					var stringLenmapkey uint64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						stringLenmapkey |= uint64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					intStringLenmapkey := int(stringLenmapkey)
					if intStringLenmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					postStringIndexmapkey := iNdEx + intStringLenmapkey
					if postStringIndexmapkey < 0 {
						return ErrInvalidLengthInstaller
					}
					if postStringIndexmapkey > l {
						return io.ErrUnexpectedEOF
					}
					mapkey = string(dAtA[iNdEx:postStringIndexmapkey])
					iNdEx = postStringIndexmapkey
				} else if fieldNum == 2 {
					var mapmsglen int
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowInstaller
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						mapmsglen |= int(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					if mapmsglen < 0 {
						return ErrInvalidLengthInstaller
					}
					postmsgIndex := iNdEx + mapmsglen
					if postmsgIndex < 0 {
						return ErrInvalidLengthInstaller
					}
					if postmsgIndex > l {
						return io.ErrUnexpectedEOF
					}
					mapvalue = &Fields{}
					if err := mapvalue.Unmarshal(dAtA[iNdEx:postmsgIndex]); err != nil {
						return err
					}
					iNdEx = postmsgIndex
				} else {
					iNdEx = entryPreIndex
					skippy, err := skipInstaller(dAtA[iNdEx:])
					if err != nil {
						return err
					}
					if skippy < 0 {
						return ErrInvalidLengthInstaller
					}
					if (iNdEx + skippy) > postIndex {
						return io.ErrUnexpectedEOF
					}
					iNdEx += skippy
				}
			}
			m.Map[mapkey] = mapvalue
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesClusterSpec) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesClusterSpec: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesClusterSpec: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Cluster", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Cluster.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Addons", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Addons.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Cluster) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Cluster: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Cluster: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TimeoutMins", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.TimeoutMins = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClusterType", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ClusterType = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PodCIDR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PodCIDR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ServiceCIDR", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ServiceCIDR = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field MasterList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.MasterList = append(m.MasterList, Node{})
			if err := m.MasterList[len(m.MasterList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExternalLoadBalancer", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ExternalLoadBalancer = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field NodeList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.NodeList = append(m.NodeList, Node{})
			if err := m.NodeList[len(m.NodeList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EtcdList", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EtcdList = append(m.EtcdList, Node{})
			if err := m.EtcdList[len(m.EtcdList)-1].Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Region", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Region = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthConfig", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.AuthConfig.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field KubeVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.KubeVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ImagesRegistry", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.ImagesRegistry = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Addons) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Addons: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Addons: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Node) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Node: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Node: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field IP", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.IP = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Role", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Role = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthConfig) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthConfig: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthConfig: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Username", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Username = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Password", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Password = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PrivateSSHKey", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PrivateSSHKey = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *KubernetesClusterRequest) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: KubernetesClusterRequest: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: KubernetesClusterRequest: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field TypeMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.TypeMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 2:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field ObjectMeta", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.ObjectMeta.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Spec", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthInstaller
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthInstaller
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if err := m.Spec.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *InstallClusterResponse) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: InstallClusterResponse: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: InstallClusterResponse: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Success", wireType)
			}
			var v int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				v |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			m.Success = bool(v != 0)
		default:
			iNdEx = preIndex
			skippy, err := skipInstaller(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if skippy < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) < 0 {
				return ErrInvalidLengthInstaller
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipInstaller(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowInstaller
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
			return iNdEx, nil
		case 1:
			iNdEx += 8
			return iNdEx, nil
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowInstaller
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthInstaller
			}
			iNdEx += length
			if iNdEx < 0 {
				return 0, ErrInvalidLengthInstaller
			}
			return iNdEx, nil
		case 3:
			for {
				var innerWire uint64
				var start int = iNdEx
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return 0, ErrIntOverflowInstaller
					}
					if iNdEx >= l {
						return 0, io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					innerWire |= (uint64(b) & 0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				innerWireType := int(innerWire & 0x7)
				if innerWireType == 4 {
					break
				}
				next, err := skipInstaller(dAtA[start:])
				if err != nil {
					return 0, err
				}
				iNdEx = start + next
				if iNdEx < 0 {
					return 0, ErrInvalidLengthInstaller
				}
			}
			return iNdEx, nil
		case 4:
			return iNdEx, nil
		case 5:
			iNdEx += 4
			return iNdEx, nil
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
	}
	panic("unreachable")
}

var (
	ErrInvalidLengthInstaller = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowInstaller   = fmt.Errorf("proto: integer overflow")
)
